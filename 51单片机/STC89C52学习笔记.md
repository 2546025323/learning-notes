#  STC89C52RC

## 综述

[TOC]

### 单片机命名规则

<img src="F:\笔记\51单片机\assets\1692337327166.png" style="zoom:60%">

### 单片机最小系统

<img src="F:\笔记\51单片机\assets\1692337467846.png" style="zoom:50%">

### 特殊功能寄存器

单片机寄存器中，能够被8整除的才可以进行位操作，不能被8整除则不能进行位操作。

<img src="F:\笔记\51单片机\assets\1692339172883.png" style="zoom:70%">

<img src="F:\笔记\51单片机\assets\1692339202473.png" style="zoom:70%">

## LED

LED又称发光二极管。

### 相关知识

#### 贴片电阻

电阻大小表示方式：

$103 = 10\times 10^{3} = 10 000 = 10k \  \Omega$

$473 = 47 \times 10^{3} = 47k \ \Omega$

#### 进制转换

<img src="F:\笔记\51单片机\assets\1690271973944.png" style="zoom:40%">

C51数据类型

<img src="F:\笔记\51单片机\assets\1690272020419.png" style="zoom:40%">

#### 运算符

<img src="F:\笔记\51单片机\assets\1690436553071.png" style="zoom:40%">

按位左移：0011 1100 << 1   =   0111 1000

按位右移：0011 1100 >> 2   =   0000 1111

异或运算：相同为0，不同为1

### 点亮一个LED

```c
#include <REGX52.H>		//内部寄存器声明
void main()
{
	while(1)
	{
		P2_0 = 0;	//LED0负极连接P2_0IO口
	}
}
```

### LED闪烁

[Delay.h](#Delay.h)

```C
#include <REGX52.H>
#include "Delay.h"
void main()
{
	while(1)
	{
		P2_0 = ~ P2_0;
		Delay(1000);
	}
}
```

### LED流水灯

[Delay.h](#Delay.h)

```c
#include <REGX52.H>
#include <INTRINS.H>	//C51内置功能函数库
#include "Delay.h"
void main()
{
	P2 = 0xFE;
	while(1)
	{
		Delay(500);
		P2 = _crol_(P2, 1); //循环左移1位
	}
}
```

## 独立按键

### 相关知识

轻触按键：相当于是一种电子开关，按下时开关接通，松开时开关断开，实现原理是通过轻触按键内部的金属弹片受力弹动来实现接通和断开

对于机械开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开，所以在开关闭合及断开的瞬间会伴随一连串的抖动

<img src="F:\笔记\51单片机\assets\1692579031357.png" style="zoom:30%">

### 独立按键控制LED亮灭

[Delay.h](#Delay.h)		[Key.h](#Key.h)

```c
#include <REGX52.H>
#include "Key.h"

void main()
{
	unsigned char KeyNum;
	while(1)
	{
		KeyNum = Key_State();
		if(KeyNum == 1)
		{
			P2_0 = ~P2_0;
		}
	}
}
```

### 独立按键控制LED二进制加减

[Delay.h](#Delay.h)		[Key.h](#Key.h)

```c
#include <REGX52.H>
#include "Key.h"
void main()
{
	unsigned char KeyNum = 0;
	P2 = 0xFF;
	while(1)
	{
		KeyNum = Key_State();
		if(KeyNum == 1)
		{
			//由于LED低电平点亮，所以P2--就是P2++;
			P2--;
		}
		else if(KeyNum == 2)
		{
			P2++;
		}
	}
}
```

### 独立按键控制LED移位

[Delay.h](#Delay.h)		[Key.h](#Key.h)

```c
#include <REGX52.H>
#include <INTRINS.H>
#include "Key.h"
#include "Delay.h"
void main()
{
	unsigned char KeyNum = 0, Flag = 0;
	P2 = 0xFE;
	while(1)
	{
		KeyNum = Key_State();		
		if(KeyNum)
		{
			// 左移1位
			if(KeyNum == 1)
			{
				P2 = _crol_(P2, 1);
			}
			//右移1位
			else if(KeyNum == 2)
			{
				P2 = _cror_(P2, 1);
			}
			//循环左移，按键按下时常应大于1s
			else if(KeyNum == 3)
			{
				while(1)
				{
					Delay(500);
					P2 = _crol_(P2, 1);
					KeyNum = Key_State();
					if(KeyNum)
						break;
				}
			}
			//循环左移，按键按下时常应大于1s
			else if(KeyNum == 4)
			{
				while(1)
				{
					Delay(500);
					P2 = _cror_(P2, 1);
					KeyNum = Key_State();
					if(KeyNum)
						break;
				}
			}
		}
	}
}
```

## 数码管

### 相关知识

LED数码管：数码管是一种简单、廉价的显示器，是由多个发光二极管封装在一起组成“8”字型的器件。

LED数码管引脚有两种接法：

|                            共阴极                            |                            共阳极                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="F:\笔记\51单片机\assets\1692663858051.png" style="zoom:40%"> | <img src="F:\笔记\51单片机\assets\1692663864620.png" style="zoom:40%"> |

数码管的驱动方式：

> 单片机直接扫描：硬件设备简单，但会耗费大量的单片机CPU时间
> 专用驱动芯片：内部自带显存、扫描电路，单片机只需告诉它显示什么即可

### 数码管静态、动态显示（单片机CPU直接扫描）

[Nixie.h](#Nixie.h)

```c
#include <REGX52.H>
#include "Nixie.h"

void main()
{
	while(1)
	{
		Nixie_ShowNum(1, 0);
		Nixie_ShowNum(2, 1);
		Nixie_ShowNum(3, 2);
		Nixie_ShowNum(4, 3);
		Nixie_ShowNum(5, 4);
		Nixie_ShowNum(6, 5);
		Nixie_ShowNum(7, 6);
		Nixie_ShowNum(8, 7);
	}
}
```

## 矩阵键盘

### 相关知识

矩阵键盘扫描（输入扫描）原理：读取第1行(列)→读取第2行(列) →读取第3行(列) → ……，然后快速循环这个过程，最终实现所有按键同时检测的效果。

扫描方式：逐行扫描或逐列扫描。

### 矩阵键盘密码锁（单片机直接扫描）

[LCD1602.h](#LCD1602.h)	[MatrixKey.h](#MatrixKey.h)

```c
#include <REGX52.H>
#include "LCD1602.h"
#include "MatrixKey.h"
unsigned char KeyNum, Count;
unsigned int Password;
unsigned int Psd_Right = 8888;
void main()
{
	LCD_Init();
	LCD_ShowString(1, 1, "Password:");
	LCD_ShowNum(2, 1, Password, 4);
	while(1)
	{
		KeyNum = MatrixKey_Num();
		if(KeyNum)
		{
			if(KeyNum <= 10 && Count < 4)
			{
				Count++;
				KeyNum%=10;
				Password*=10;
				Password+=KeyNum;
				LCD_ShowNum(2, 1, Password, 4);
				LCD_ShowString(1, 14, "   ");
			}
			if(KeyNum == 11)
			{
				Count = 0;
				LCD_ShowNum(2, 1, 0, 4);
				if(Password == Psd_Right)
				{
					LCD_ShowString(1, 14, "OK ");
				}
				else
				{
					LCD_ShowString(1, 14, "ERR");
				}
				Password = 0;
			}
			if(KeyNum == 12)
			{
				Count = 0;
				Password = 0;
				LCD_ShowNum(2, 1, Password, 4);
				LCD_ShowString(1, 14, "   ");
			}
		}
	}
}
```



## 中断系统

### 中断查询次序

<img src="F:\笔记\51单片机\assets\1692756720553.png" style="zoom:50%"/>

### 中断结构

<img src="F:\笔记\51单片机\assets\1692756896045.png" style="zoom:90%"/>

### 中断寄存器

<img src="F:\笔记\51单片机\assets\1692757495023.png" style="zoom:50%"/>

#### 中断允许寄存器IE和XICON

<img src="F:\笔记\51单片机\assets\1692836933188.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1692837264865.png" style="zoom:60%">

#### 中断优先级控制寄存器IP/XICON和IPH

中断遵循以下规则：

>1. 低优先级中断可被高优先级中断所中断，反之不能。
>2. 任何一种中断(不管是高级还是低级)，一旦得到响应，不会再被它的同�=级中断所中断。

每种中断共4个优先级，以定时器0为例：

> PT0H=0，PT0=0：定时器0为最低优先级中断（优先级0）
>
> PT0H=0，PT0=1：定时器0为较低优先级中断（优先级1）
>
> PT0H=1，PT0=0：定时器0为较高优先级中断（优先级2）
>
> PT0H=1，PT0=1：定时器0为最高优先级中断（优先级3）

STC89C51RC/RD+系列单片机复位后，IP和IPH均为00H各个中断源均为低优先级中断

<img src="F:\笔记\51单片机\assets\1692838434943.png" style="zoom:60%">

#### 定时器/计数器0/1控制寄存器TCON

<img src="F:\笔记\51单片机\assets\1692839669975.png" style="zoom:65%">

#### 串行口控制寄存器SCON

<img src="F:\笔记\51单片机\assets\1692840140735.png" style="zoom:65%">

#### 定时器/计数器2控制寄存器T2CON

<img src="F:\笔记\51单片机\assets\1692841173505.png" style="zoom:65%">

## 定时器/计数器

### 定时器/计数器控制寄存器TCON

<img src="F:\笔记\51单片机\assets\1692854922550.png" style="zoom:80%">

### 定时器/计数器工作模式寄存器TMOD

<img src="F:\笔记\51单片机\assets\1693373876824.png" style="zoom:80%">

### 定时器/计数器0的模式 0: 13位定时器/计数器

定时器/计数器0与定时器/计数器1类似，以定时器/计数器0为例。

#### 模式0(13位定时器/计数器)

<img src="F:\笔记\51单片机\assets\1693374245238.png" style="zoom:50%">

#### 模式1(16位定时器/计数器)

<img src="F:\笔记\51单片机\assets\1693374605433.png" style="zoom:53%">

#### 模式2(8位自动重装模式)

<img src="F:\笔记\51单片机\assets\1693374867030.png" style="zoom:50%">

#### 模式3(两个8位计数器)

<img src="F:\笔记\51单片机\assets\1693374958069.png" style="zoom:53%">

## 定时器的应用

### 定时器控制流水灯

[Timer0.h](#Timer0.h)	[Key.h](#Key.h)

```c
#include <REGX52.H>
#include <INTRINS.H>
#include "Timer0.h"
#include "Key.h"
unsigned char KeyNum, Model, Temp;
void main()
{
	Timer0_Init();
	P2=0xFE;
	Temp=0x01;
	while(1)
	{
		KeyNum = Key_State();
		if(KeyNum==1)
		{
			Model=1;
		}
		else if(KeyNum==2)
		{
			Model = 2;
		}
	}
}

void Timer0_Routine(void)	interrupt 1
{
	static unsigned int T0Count = 0;
	TL0 = 0x66;				//设置定时初始值
	TH0 = 0xFC;			//设置定时初始值
	T0Count++;
	if(T0Count>=1000)
	{
		if(Model==1)
		{
			Temp = _crol_(Temp, 1);
			P2=~Temp;
		}
		else if(Model==2)
		{
			Temp = _cror_(Temp, 1);
			P2=~Temp;
		}
		T0Count=0;
	}
}
```

### 定时器时钟

[Timer0.h](#Timer0.h)	[LCD1602.h](#LCD1602.h)

```c
#include <REGX52.H>
#include "Timer0.h"
#include "LCD1602.h"
unsigned char Hour=23, Min=59, Sec=55;
void main()
{
	Timer0_Init();
	LCD_Init();
	while(1)
	{
		LCD_ShowNum(1, 1, Hour, 2);
		LCD_ShowChar(1, 3, '-');
		LCD_ShowNum(1, 4, Min, 2);
		LCD_ShowChar(1, 6, '-');
		LCD_ShowNum(1, 7, Sec, 2);	
	}
}
void Timer0_Routine(void)	interrupt 1
{
	static unsigned int T0Count;
	TL0 = 0x66;				//设置定时初始值
	TH0 = 0xFC;				//设置定时初始值
	T0Count++;
	if(T0Count>=1000)
	{
		Sec++;
		if(Sec>=60)
		{
			Sec=0;
			Min++;
			if(Min>=60)
			{
				Min=0;
				Hour++;
				if(Hour>=24)
				{
					Hour=0;
				}
			}
		}
		T0Count=0;
	}
}
```

## 串口通信

### 相关知识

<img src="F:\笔记\51单片机\assets\1694758587055.png" style="zoom:88%">

<img src="F:\笔记\51单片机\assets\1694758722551.png" style="zoom:44%">

### 串口向电脑发送数据

[Delay.h](#Delay.h)	[UART.h](#UART.h)

```c
#include <REGX52.H>
#include "UART.h"
#include "Delay.h"
unsigned char Sec;
void main()
{
	UART_Init();
	while(1)
	{
		Delay(1000);
		UART_SendData(Sec++);
	}
}
```

### 串口与电脑相互通信

```c
#include <REGX52.H>
#include "Delay.h"
#include "UART.h"
unsigned char Data;
void main()
{
	UartInit();
	while(1)
	{
		if(Data == 0xFF)
		{
			P2 = 0xFE;
		}
		else
		{
			P2 = 0xF0;
		}
	}
}
void UART_Routine(void)	interrupt 4
{
	Data = UART_ReceiveData();
	RI = 0;
}
```

## LED点阵屏

### 相关知识

- LED点阵屏的结构类似于数码管，只不过是数码管把每一列的像素以“8”字型排列而已
- LED点阵屏与数码管一样，有共阴和共阳两种接法，不同的接法对应的电路结构不同
- LED点阵屏需要进行逐行或逐列扫描，才能使所有LED同时显示

### 点阵屏显示图像

[74HC595.h](#74HC595.h)	[MatrixLED.h](#MatrixLED.h)

```c
#include <REGX52.H>
#include "74HC595.h"
#include "MatrixLED.h"
unsigned char Smile[] = {0x3C,0x42,0x95,0xA1,0xA1,0x95,0x42,0x3C};
void main()
{
	_74HC595_Init();
	while(1)
	{
		unsigned char i;
		for(i=0;i<8;i++)
		{
			MatrixLED_Show(i, Smile[i]);
		}
	}
}
```

### 点阵屏显示动画

[74HC595.h](#74HC595.h)	[MatrixLED.h](#MatrixLED.h)

```c
#include <REGX52.H>
#include "MatrixLED.h"
#include "74HC595.h"
#include "Delay.h"
unsigned char code Cartoon[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0xFF,0x08,0x18,0x10,0xFF,0x00,0x00,0xF7,
	0x08,0x10,0xEF,0x00,0x00,0xFF,0x01,0x06,
	0x18,0x06,0x01,0xFF,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00};
unsigned char Offset = 0, Count = 0;
void main()
{
	_74HC595_Init();
	while(1)
	{
		unsigned char i;
		for(i=0;i<8;i++)
		{
			MatrixLED_Show(i,Cartoon[i + Offset]);
		}
		Count++;
		if(Count > 20)
		{
			Count = 0;
			Offset++;
			if(Offset == 30)
			{
				Offset = 0;
			}
		}
	}
}
```

## DS1302时钟芯片

DS1302是由美国DALLAS公司推出的具有涓细电流充电能力的低功耗实时时钟芯片。它可以对年、月、日、周、时、分、秒进行计时，且具有闰年补偿等多种功能。
RTC(Real Time Clock)：实时时钟，是一种集成电路，通常称为时钟芯片。

### 相关知识

引脚定义和应用电路

<img src="F:\笔记\51单片机\assets\1694831383434.png" style="zoom:50%">

内部结构框图

<img src="F:\笔记\51单片机\assets\1694833484477.png" style="zoom:50%">

寄存器定义

<img src="F:\笔记\51单片机\assets\1694924004717.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694924064561.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694931574714.png" style="zoom:40%">

BCD码

- BCD码（Binary Coded Decimal?），用4位二进制数来表示1位十进制数
- 例：0001 0011表示13，1000 0101表示85，0001 1010不合法
- 在十六进制中的体现：0x13表示13，0x85表示85，0x1A不合法
- BCD码转十进制：DEC=BCD/16*10+BCD%16; （2位BCD）*
- *十进制转BCD码：BCD=DEC/10*16+DEC%10; （2位BCD）

### DS1302时钟

[LCD1602.h](#LCD1602.h)	[DS1302.h](#DS1302.h)

```c
#include <REGX52.H>
#include "LCD1602.h"
#include "DS1302.h"
void main()
{
	LCD_Init();
	DS1302_Init();
	LCD_ShowString(1,1,"  -  -  ");//静态字符初始化显示
	LCD_ShowString(2,1,"  :  :  ");
	
	DS1302_SetTime();//设置时间
	
	while(1)
	{
		DS1302_ReadTime();//读取时间
		LCD_ShowNum(1,1,DS1302_Time[0],2);//显示年
		LCD_ShowNum(1,4,DS1302_Time[1],2);//显示月
		LCD_ShowNum(1,7,DS1302_Time[2],2);//显示日
		LCD_ShowNum(2,1,DS1302_Time[3],2);//显示时
		LCD_ShowNum(2,4,DS1302_Time[4],2);//显示分
		LCD_ShowNum(2,7,DS1302_Time[5],2);//显示秒
	}
}
```

## 蜂鸣器

### 相关知识

- 蜂鸣器是一种将电信号转换为声音信号的器件，常用来产生设备的按键音、报警音等提示信号

- 蜂鸣器按驱动方式可分为有源蜂鸣器和无源蜂鸣器
  - 有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定
  - 无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音

<img src="F:\笔记\51单片机\assets\1694932132934.png" style="zoom:50%">

### 蜂鸣器播放提示音

[Delay.h](#Delay.h)	[Key.h](#Key.h)	[Nixie.h](#Nixie.h)	[Buzzer.h](#Buzzer.h)

```c
#include <REGX52.H>
#include "Delay.h"
#include "Key.h"
#include "Nixie.h"
#include "Buzzer.h"
unsigned char KeyNum;
void main()
{
	Nixie(1,0);
	while(1)
	{
		KeyNum=Key();
		if(KeyNum)
		{
			Buzzer_Time(100);
			Nixie(1,KeyNum);
		}
	}
}
```

## AT24C02

### 相关知识

- AT24C02是一种可以实现掉电不丢失的存储器，可用于保存单片机运行时想要永久保存的数据信息
- 存储介质：E2PROM
- 通讯接口：I2C总线
- 容量：256字节

引脚及电路应用

<img src="F:\笔记\51单片机\assets\1694932613198.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694932646951.png" style="zoom:50%">

### I²C总线

- I2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线
- 两根通信线：SCL（Serial Clock）、SDA（Serial Data）
- 同步、半双工，带数据应答

#### I²C电路规范

- 所有I2C设备的SCL连在一起，SDA连在一起
- 设备的SCL和SDA均要配置成开漏输出模式
- SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右
- 开漏输出和上拉电阻的共同作用实现了“线与”的功能，此设计主要是为了解决多机通信互相干扰的问题

<img src="F:\笔记\51单片机\assets\1694932939332.png" style="zoom:50%">

#### I²C的时序结构

<img src="F:\笔记\51单片机\assets\1694933167255.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694933262329.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694933338416.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694933375599.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694933590176.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694933600660.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694933634786.png" style="zoom:50%">

### AT24C02数据存储

[LCD1602.h](#LCD1602.h)	[Key.h](#Key.h)	[AT24C02.h](#AT24C02.h)	[Delay.h](#Delay.h)

```c
#include <REGX52.H>
#include "LCD1602.h"
#include "Key.h"
#include "AT24C02.h"
#include "Delay.h"
unsigned char KeyNum;
unsigned int Num;
void main()
{
	LCD_Init();
	LCD_ShowNum(1,1,Num,5);
	while(1)
	{
		KeyNum=Key();
		if(KeyNum==1)	//K1按键，Num自增
		{
			Num++;
			LCD_ShowNum(1,1,Num,5);
		}
		if(KeyNum==2)	//K2按键，Num自减
		{
			Num--;
			LCD_ShowNum(1,1,Num,5);
		}
		if(KeyNum==3)	//K3按键，向AT24C02写入数据
		{
			AT24C02_WriteByte(0,Num%256);
			Delay(5);
			AT24C02_WriteByte(1,Num/256);
			Delay(5);
			LCD_ShowString(2,1,"Write OK");
			Delay(1000);
			LCD_ShowString(2,1,"        ");
		}
		if(KeyNum==4)	//K4按键，从AT24C02读取数据
		{
			Num=AT24C02_ReadByte(0);
			Num|=AT24C02_ReadByte(1)<<8;
			LCD_ShowNum(1,1,Num,5);
			LCD_ShowString(2,1,"Read OK ");
			Delay(1000);
			LCD_ShowString(2,1,"        ");
		}
	}
}
```

### 秒表（定时器扫描按键数码管）

[Timer0.h](#Timer0.h)	[Key.h](#Key.h)	[Nixie.h](#Nixie.h)	[Delay.h](#Delay.h)	[AT24C02.h](#AT24C02.h)

```c
#include <REGX52.H>
#include "Timer0.h"
#include "Key.h"
#include "Nixie.h"
#include "Delay.h"
#include "AT24C02.h"

unsigned char KeyNum;
unsigned char Min,Sec,MiniSec;
unsigned char RunFlag;

void main()
{
	Timer0_Init();
	while(1)
	{
		KeyNum=Key();
		if(KeyNum==1)			//K1按键按下
		{
			RunFlag=!RunFlag;	//启动标志位翻转
		}
		if(KeyNum==2)			//K2按键按下
		{
			Min=0;				//分秒清0
			Sec=0;
			MiniSec=0;
		}
		if(KeyNum==3)			//K3按键按下
		{
			AT24C02_WriteByte(0,Min);	//将分秒写入AT24C02
			Delay(5);
			AT24C02_WriteByte(1,Sec);
			Delay(5);
			AT24C02_WriteByte(2,MiniSec);
			Delay(5);
		}
		if(KeyNum==4)			//K4按键按下
		{
			Min=AT24C02_ReadByte(0);	//读出AT24C02数据
			Sec=AT24C02_ReadByte(1);
			MiniSec=AT24C02_ReadByte(2);
		}
		Nixie_SetBuf(1,Min/10);	//设置显示缓存，显示数据
		Nixie_SetBuf(2,Min%10);
		Nixie_SetBuf(3,11);
		Nixie_SetBuf(4,Sec/10);
		Nixie_SetBuf(5,Sec%10);
		Nixie_SetBuf(6,11);
		Nixie_SetBuf(7,MiniSec/10);
		Nixie_SetBuf(8,MiniSec%10);
	}
}

/**
  * @brief  秒表驱动函数，在中断中调用
  * @param  无
  * @retval 无
  */
void Sec_Loop(void)
{
	if(RunFlag)
	{
		MiniSec++;
		if(MiniSec>=100)
		{
			MiniSec=0;
			Sec++;
			if(Sec>=60)
			{
				Sec=0;
				Min++;
				if(Min>=60)
				{
					Min=0;
				}
			}
		}
	}
}

void Timer0_Routine() interrupt 1
{
	static unsigned int T0Count1,T0Count2,T0Count3;
	TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	T0Count1++;
	if(T0Count1>=20)
	{
		T0Count1=0;
		Key_Loop();	//20ms调用一次按键驱动函数
	}
	T0Count2++;
	if(T0Count2>=2)
	{
		T0Count2=0;
		Nixie_Loop();//2ms调用一次数码管驱动函数
	}
	T0Count3++;
	if(T0Count3>=10)
	{
		T0Count3=0;
		Sec_Loop();	//10ms调用一次数秒表驱动函数
	}
}
```

## DS18B20

### 相关知识

- DS18B20是一种常见的数字温度传感器，其控制命令和数据都是以数字信号的方式输入输出，相比较于模拟温度传感器，具有功能强大、硬件简单、易扩展、抗干扰性强等特点
- 测温范围：-55°C 到 +125°C
- 通信接口：1-Wire（单总线）

#### 引脚及应用电路

<img src="F:\笔记\51单片机\assets\1694935856329.png" style="zoom:50%">

#### 内部结构框图

<img src="F:\笔记\51单片机\assets\1694935917892.png" style="zoom:50%">

#### 存储器结构

<img src="F:\笔记\51单片机\assets\1694936069561.png" style="zoom:50%">

#### 芯片操作流程

<img src="F:\笔记\51单片机\assets\1694936489481.png" style="zoom:50%">

#### 芯片数据帧

<img src="F:\笔记\51单片机\assets\1694936536310.png" style="zoom:50%">

#### 温度存储格式

<img src="F:\笔记\51单片机\assets\1694936583831.png" style="zoom:50%">

### 单总线（one-wire）

- 单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线
- 一根通信线：DQ
- 异步、半双工
- 单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线

#### 单总线电路规范

<img src="F:\笔记\51单片机\assets\1694936204936.png" style="zoom:50%">

#### 单总线时序结构

<img src="F:\笔记\51单片机\assets\1694936297185.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694936313545.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694936323872.png" style="zoom:50%">

<img src="F:\笔记\51单片机\assets\1694936349046.png" style="zoom:50%">

### DS18B20温度读取

[LCD1602.h](#LCD1602.h)	[DS18B20.h](#DS18B20.h)	[Delay.h](#Delay.h)

```c
#include <REGX52.H>
#include "LCD1602.h"
#include "DS18B20.h"
#include "Delay.h"
float T;
void main()
{
	DS18B20_ConvertT();		//上电先转换一次温度，防止第一次读数据错误
	Delay(1000);			//等待转换完成
	LCD_Init();
	LCD_ShowString(1,1,"Temperature:");
	while(1)
	{
		DS18B20_ConvertT();	//转换温度
		T=DS18B20_ReadT();	//读取温度
		if(T<0)				//如果温度小于0
		{
			LCD_ShowChar(2,1,'-');	//显示负号
			T=-T;			//将温度变为正数
		}
		else				//如果温度大于等于0
		{
			LCD_ShowChar(2,1,'+');	//显示正号
		}
		LCD_ShowNum(2,2,T,3);		//显示温度整数部分
		LCD_ShowChar(2,5,'.');		//显示小数点
		LCD_ShowNum(2,6,(unsigned long)(T*10000)%10000,4);//显示温度小数部分
	}
}
```

### DS18B20温度报警器

[LCD1602.h](#LCD1602.h)	[DS18B20.h](#DS18B20.h)	[Delay.h](#Delay.h)	[AT24C02.h](#AT24C02.h)	[Key.h](#Key.h)	[Timer0.h](#Timer0.h)

```c
#include <REGX52.H>
#include "LCD1602.h"
#include "DS18B20.h"
#include "Delay.h"
#include "AT24C02.h"
#include "Key.h"
#include "Timer0.h"

float T,TShow;
char TLow,THigh;
unsigned char KeyNum;

void main()
{
	DS18B20_ConvertT();		//上电先转换一次温度，防止第一次读数据错误
	Delay(1000);			//等待转换完成
	THigh=AT24C02_ReadByte(0);	//读取温度阈值数据
	TLow=AT24C02_ReadByte(1);
	if(THigh>125 || TLow<-55 || THigh<=TLow)
	{
		THigh=20;			//如果阈值非法，则设为默认值
		TLow=15;
	}
	LCD_Init();
	LCD_ShowString(1,1,"T:");
	LCD_ShowString(2,1,"TH:");
	LCD_ShowString(2,9,"TL:");
	LCD_ShowSignedNum(2,4,THigh,3);
	LCD_ShowSignedNum(2,12,TLow,3);
	Timer0_Init();
	
	while(1)
	{
		KeyNum=Key();
		
		/*温度读取及显示*/
		DS18B20_ConvertT();	//转换温度
		T=DS18B20_ReadT();	//读取温度
		if(T<0)				//如果温度小于0
		{
			LCD_ShowChar(1,3,'-');	//显示负号
			TShow=-T;		//将温度变为正数
		}
		else				//如果温度大于等于0
		{
			LCD_ShowChar(1,3,'+');	//显示正号
			TShow=T;
		}
		LCD_ShowNum(1,4,TShow,3);		//显示温度整数部分
		LCD_ShowChar(1,7,'.');		//显示小数点
		LCD_ShowNum(1,8,(unsigned long)(TShow*100)%100,2);//显示温度小数部分
		
		/*阈值判断及显示*/
		if(KeyNum)
		{
			if(KeyNum==1)	//K1按键，THigh自增
			{
				THigh++;
				if(THigh>125){THigh=125;}
			}
			if(KeyNum==2)	//K2按键，THigh自减
			{
				THigh--;
				if(THigh<=TLow){THigh++;}
			}
			if(KeyNum==3)	//K3按键，TLow自增
			{
				TLow++;
				if(TLow>=THigh){TLow--;}
			}
			if(KeyNum==4)	//K4按键，TLow自减
			{
				TLow--;
				if(TLow<-55){TLow=-55;}
			}
			LCD_ShowSignedNum(2,4,THigh,3);	//显示阈值数据
			LCD_ShowSignedNum(2,12,TLow,3);
			AT24C02_WriteByte(0,THigh);		//写入到At24C02中保存
			Delay(5);
			AT24C02_WriteByte(1,TLow);
			Delay(5);
		}
		if(T>THigh)			//越界判断
		{
			LCD_ShowString(1,13,"OV:H");
		}
		else if(T<TLow)
		{
			LCD_ShowString(1,13,"OV:L");
		}
		else
		{
			LCD_ShowString(1,13,"    ");
		}
	}
}

void Timer0_Routine() interrupt 1
{
	static unsigned int T0Count;
	TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	T0Count++;
	if(T0Count>=20)
	{
		T0Count=0;
		Key_Loop();	//每20ms调用一次按键驱动函数
	}
}
```

## LCD1602

### 相关知识

- LCD1602（Liquid Crystal Display）液晶显示屏是一种字符型液晶显示模块，可以显示ASCII码的标准字符和其它的一些内置特殊字符，还可以有8个自定义字符
- 显示容量：16×2个字符，每个字符为5*7点阵

#### 引脚及应用电路

<img src="F:\笔记\51单片机\assets\1694937502717.png" style="zoom:50%">

#### 内部结构图

<img src="F:\笔记\51单片机\assets\1694937608791.png" style="zoom:50%">

#### 存储器结构

<img src="F:\笔记\51单片机\assets\1694937846522.png" style="zoom:50%">

#### 时序结构

<img src="F:\笔记\51单片机\assets\1694938117179.png" style="zoom:50%">

#### 指令集

<img src="F:\笔记\51单片机\assets\1694938125341.png" style="zoom:50%">

#### 操作流程

<img src="F:\笔记\51单片机\assets\1694938134671.png" style="zoom:50%">

## 直流电机驱动（PWM）

### 相关知识

- PWM（Pulse Width Modulation）即脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速、开关电源等领域
- PWM重要参数：
       频率 = 1 / TS            占空比 = TON / TS           精度 = 占空比变化步距

<img src="F:\笔记\51单片机\assets\1694939008714.png" style="zoom:50%">

### 直流电机调速

[Delay.h](#Delay.h)	[Key.h](#Key.h)	[Nixie.h](#Nixie.h)	[Timer0.h](#Timer0.h)

```c
#include <REGX52.H>
#include "Delay.h"
#include "Key.h"
#include "Nixie.h"
#include "Timer0.h"

sbit Motor=P1^0;

unsigned char Counter,Compare;	//计数值和比较值，用于输出PWM
unsigned char KeyNum,Speed;

void main()
{
	Timer0_Init();
	while(1)
	{
		KeyNum=Key();
		if(KeyNum==1)
		{
			Speed++;
			Speed%=4;
			if(Speed==0){Compare=0;}	//设置比较值，改变PWM占空比
			if(Speed==1){Compare=50;}
			if(Speed==2){Compare=75;}
			if(Speed==3){Compare=100;}
		}
		Nixie(1,Speed);
	}
}

void Timer0_Routine() interrupt 1
{
	TL0 = 0x9C;		//设置定时初值
	TH0 = 0xFF;		//设置定时初值
	Counter++;
	Counter%=100;	//计数值变化范围限制在0~99
	if(Counter<Compare)	//计数值小于比较值
	{
		Motor=1;		//输出1
	}
	else				//计数值大于比较值
	{
		Motor=0;		//输出0
	}
}
```

## AD/DA

### 相关知识

AD（Analog to Digital）：模拟-数字转换，将模拟信号转换为计算机可操作的数字信号
DA（Digital to Analog）：数字-模拟转换，将计算机输出的数字信号转换为模拟信号
AD/DA转换打开了计算机与模拟信号的大门，极大的提高了计算机系统的应用范围，也为模拟信号数字化处理提供了可能

### XPT2046

<img src="F:\笔记\51单片机\assets\1694939401781.png" style="zoom:50%">

#### 时序结构

<img src="F:\笔记\51单片机\assets\1694939442142.png" style="zoom:50%">

### AD模数转换

[Delay.h](#Delay.h)	[LCD1602.h](#LCD1602.h)	[XPT2046.h](#XPT2046.h)

```c
#include <REGX52.H>
#include "Delay.h"
#include "LCD1602.h"
#include "XPT2046.h"

unsigned int ADValue;

void main(void)
{
	LCD_Init();
	LCD_ShowString(1,1,"ADJ  NTC  GR");
	while(1)
	{
		ADValue=XPT2046_ReadAD(XPT2046_XP);		//读取AIN0，可调电阻
		LCD_ShowNum(2,1,ADValue,3);				//显示AIN0
		ADValue=XPT2046_ReadAD(XPT2046_YP);		//读取AIN1，热敏电阻
		LCD_ShowNum(2,6,ADValue,3);				//显示AIN1
		ADValue=XPT2046_ReadAD(XPT2046_VBAT);	//读取AIN2，光敏电阻
		LCD_ShowNum(2,11,ADValue,3);			//显示AIN2
		Delay(100);
	}
}
```

### DA数模转换

[Delay.h](#Delay.h)	[Tiemr0.h](#Timer0.h)

```c
#include <REGX52.H>
#include "Delay.h"
#include "Timer0.h"

sbit DA=P2^1;

unsigned char Counter,Compare;	//计数值和比较值，用于输出PWM
unsigned char i;

void main()
{
	Timer0_Init();
	while(1)
	{
		for(i=0;i<100;i++)
		{
			Compare=i;			//设置比较值，改变PWM占空比
			Delay(10);
		}
		for(i=100;i>0;i--)
		{
			Compare=i;			//设置比较值，改变PWM占空比
			Delay(10);
		}
	}
}

void Timer0_Routine() interrupt 1
{
	TL0 = 0x9C;		//设置定时初值
	TH0 = 0xFF;		//设置定时初值
	Counter++;
	Counter%=100;	//计数值变化范围限制在0~99
	if(Counter<Compare)	//计数值小于比较值
	{
		DA=1;		//输出1
	}
	else				//计数值大于比较值
	{
		DA=0;		//输出0
	}
}
```

## 红外遥控

### 相关知识

红外遥控是利用红外光进行通信的设备，由红外LED将调制后的信号发出，由专用的红外接收头进行解调输出
通信方式：单工，异步
红外LED波长：940nm
通信协议标准：NEC标准

#### 基本发送与接收

<img src="F:\笔记\51单片机\assets\1694939853865.png" style="zoom:50%">

### NEC编码

<img src="F:\笔记\51单片机\assets\1694939896529.png" style="zoom:50%">

### 红外遥控

[Delay.h](#Delay.h)	[LCD1602.h](#LCD1602.h)	[IR.h](#IR.h)

```c
#include <REGX52.H>
#include "Delay.h"
#include "LCD1602.h"
#include "IR.h"

unsigned char Num;
unsigned char Address;
unsigned char Command;

void main()
{
	LCD_Init();
	LCD_ShowString(1,1,"ADDR  CMD  NUM");
	LCD_ShowString(2,1,"00    00   000");
	
	IR_Init();
	
	while(1)
	{
		if(IR_GetDataFlag() || IR_GetRepeatFlag())	//如果收到数据帧或者收到连发帧
		{
			Address=IR_GetAddress();		//获取遥控器地址码
			Command=IR_GetCommand();		//获取遥控器命令码
			
			LCD_ShowHexNum(2,1,Address,2);	//显示遥控器地址码
			LCD_ShowHexNum(2,7,Command,2);	//显示遥控器命令码
			
			if(Command==IR_VOL_MINUS)		//如果遥控器VOL-按键按下
			{
				Num--;						//Num自减
			}
			if(Command==IR_VOL_ADD)			//如果遥控器VOL+按键按下
			{
				Num++;						//Num自增
			}
			
			LCD_ShowNum(2,12,Num,3);		//显示Num
		}
	}
}
```



## 附录

### Delay.h

```c
#ifndef __DELAY_H__
#define __DELAY_H__

void Delay(unsigned char xms);

#endif
```

```c
/**
  * @brief  软件延时x毫秒
  * @param  xms x毫秒
  * @retval 无
  */
void Delay(unsigned char xms)		//@11.0592MHz
{
	while(xms--)
	{
		unsigned char data i, j;

		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);	
	}
}
```

### Key.h

```c
#ifndef __KEY_H__
#define __KEY_H__

unsigned char Key(void);
void Key_Loop(void);

#endif
```

```c
#include <REGX52.H>
#include "Delay.h"

unsigned char Key_KeyNumber;

/**
  * @brief  获取按键键码
  * @param  无
  * @retval 按下按键的键码，范围：0,1~4,0表示无按键按下
  */
unsigned char Key(void)
{
	unsigned char Temp=0;
	Temp=Key_KeyNumber;
	Key_KeyNumber=0;
	return Temp;
}

/**
  * @brief  获取当前按键的状态，无消抖及松手检测
  * @param  无
  * @retval 按下按键的键码，范围：0,1~4,0表示无按键按下
  */
unsigned char Key_GetState()
{
	unsigned char KeyNumber=0;
	
	if(P3_1==0){KeyNumber=1;}
	if(P3_0==0){KeyNumber=2;}
	if(P3_2==0){KeyNumber=3;}
	if(P3_3==0){KeyNumber=4;}
	
	return KeyNumber;
}

/**
  * @brief  按键驱动函数，在中断中调用
  * @param  无
  * @retval 无
  */
void Key_Loop(void)
{
	static unsigned char NowState,LastState;
	LastState=NowState;				//按键状态更新
	NowState=Key_GetState();		//获取当前按键状态
	//如果上个时间点按键按下，这个时间点未按下，则是松手瞬间，以此避免消抖和松手检测
	if(LastState==1 && NowState==0)
	{
		Key_KeyNumber=1;
	}
	if(LastState==2 && NowState==0)
	{
		Key_KeyNumber=2;
	}
	if(LastState==3 && NowState==0)
	{
		Key_KeyNumber=3;
	}
	if(LastState==4 && NowState==0)
	{
		Key_KeyNumber=4;
	}
}
```

### Nixie.h

```c
#ifndef __NIXIE_H__
#define __NIXIE_H__

void Nixie_SetBuf(unsigned char Location,Number);
void Nixie_Scan(unsigned char Location,Number);
void Nixie_Loop(void);

#endif
```

```c
#include <REGX52.H>
#include "Delay.h"

//数码管显示缓存区
unsigned char Nixie_Buf[9]={0,10,10,10,10,10,10,10,10};

//数码管段码表
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x00,0x40};

/**
  * @brief  设置显示缓存区
  * @param  Location 要设置的位置，范围：1~8
  * @param  Number 要设置的数字，范围：段码表索引范围
  * @retval 无
  */
void Nixie_SetBuf(unsigned char Location,Number)
{
	Nixie_Buf[Location]=Number;
}

/**
  * @brief  数码管扫描显示
  * @param  Location 要显示的位置，范围：1~8
  * @param  Number 要显示的数字，范围：段码表索引范围
  * @retval 无
  */
void Nixie_Scan(unsigned char Location,Number)
{
	P0=0x00;				//段码清0，消影
	switch(Location)		//位码输出
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];	//段码输出
}

/**
  * @brief  数码管驱动函数，在中断中调用
  * @param  无
  * @retval 无
  */
void Nixie_Loop(void)
{
	static unsigned char i=1;
	Nixie_Scan(i,Nixie_Buf[i]);
	i++;
	if(i>=9){i=1;}
}
```

### MatrixKey.h

```c
#ifndef __MATRIXKEY_H__
#define __MATRIXKEY_H__

unsigned char MatrixKey_Num(void);

#endif
```

```c
#include <REGX52.H>
#include "Delay.h"
sbit MatrixKey_A1 = P1^0;
sbit MatrixKey_A2 = P1^1;
sbit MatrixKey_A3 = P1^2;
sbit MatrixKey_A4 = P1^3;
sbit MatrixKey_B1 = P1^4;
sbit MatrixKey_B2 = P1^5;
sbit MatrixKey_B3 = P1^6;
sbit MatrixKey_B4 = P1^7;
#define MatrixKey_IO	P1
/**
  * @brief  按列扫描矩阵键盘
  * @param  无
  * @retval KeyNum，矩阵键盘返回值，范围0~16，0为未检测到输入，反之则有。
  */
unsigned char MatrixKey_Num(void)
{
	unsigned char KeyNum = 0;
	MatrixKey_IO = 0xFF;
	MatrixKey_A4 = 0;
	if(MatrixKey_B4 == 0){Delay(20);while(MatrixKey_B4 == 0);Delay(20);KeyNum=1;}
	if(MatrixKey_B3 == 0){Delay(20);while(MatrixKey_B3 == 0);Delay(20);KeyNum=5;}
	if(MatrixKey_B2 == 0){Delay(20);while(MatrixKey_B2 == 0);Delay(20);KeyNum=9;}
	if(MatrixKey_B1 == 0){Delay(20);while(MatrixKey_B1 == 0);Delay(20);KeyNum=13;}
	MatrixKey_IO = 0xFF;
	MatrixKey_A3 = 0;
	if(MatrixKey_B4 == 0){Delay(20);while(MatrixKey_B4 == 0);Delay(20);KeyNum=2;}
	if(MatrixKey_B3 == 0){Delay(20);while(MatrixKey_B3 == 0);Delay(20);KeyNum=6;}
	if(MatrixKey_B2 == 0){Delay(20);while(MatrixKey_B2 == 0);Delay(20);KeyNum=10;}
	if(MatrixKey_B1 == 0){Delay(20);while(MatrixKey_B1 == 0);Delay(20);KeyNum=14;}
	MatrixKey_IO = 0xFF;
	MatrixKey_A2 = 0;
	if(MatrixKey_B4 == 0){Delay(20);while(MatrixKey_B4 == 0);Delay(20);KeyNum=3;}
	if(MatrixKey_B3 == 0){Delay(20);while(MatrixKey_B3 == 0);Delay(20);KeyNum=7;}
	if(MatrixKey_B2 == 0){Delay(20);while(MatrixKey_B2 == 0);Delay(20);KeyNum=11;}
	if(MatrixKey_B1 == 0){Delay(20);while(MatrixKey_B1 == 0);Delay(20);KeyNum=15;}
	MatrixKey_IO = 0xFF;
	MatrixKey_A1 = 0;
	if(MatrixKey_B4 == 0){Delay(20);while(MatrixKey_B4 == 0);Delay(20);KeyNum=4;}
	if(MatrixKey_B3 == 0){Delay(20);while(MatrixKey_B3 == 0);Delay(20);KeyNum=8;}
	if(MatrixKey_B2 == 0){Delay(20);while(MatrixKey_B2 == 0);Delay(20);KeyNum=12;}
	if(MatrixKey_B1 == 0){Delay(20);while(MatrixKey_B1 == 0);Delay(20);KeyNum=16;}
	return KeyNum;
}
```

### LCD1602.h

```c
#ifndef __LCD1602_H__
#define __LCD1602_H__

//用户调用函数：
void LCD_Init();
void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char);
void LCD_ShowString(unsigned char Line,unsigned char Column,char *String);
void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);
void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length);
void LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);
void LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);

#endif
```

```c
#include <REGX52.H>
//引脚配置：
sbit LCD_RS=P2^6;
sbit LCD_RW=P2^5;
sbit LCD_EN=P2^7;
#define LCD_DataPort P0
//函数定义：
/**
  * @brief  LCD1602延时函数，12MHz调用可延时1ms
  * @param  无
  * @retval 无
  */
void LCD_Delay()
{
	unsigned char i, j;

	i = 2;
	j = 239;
	do
	{
		while (--j);
	} while (--i);
}
/**
  * @brief  LCD1602写命令
  * @param  Command 要写入的命令
  * @retval 无
  */
void LCD_WriteCommand(unsigned char Command)
{
	LCD_RS=0;
	LCD_RW=0;
	LCD_DataPort=Command;
	LCD_EN=1;
	LCD_Delay();
	LCD_EN=0;
	LCD_Delay();
}
/**
  * @brief  LCD1602写数据
  * @param  Data 要写入的数据
  * @retval 无
  */
void LCD_WriteData(unsigned char Data)
{
	LCD_RS=1;
	LCD_RW=0;
	LCD_DataPort=Data;
	LCD_EN=1;
	LCD_Delay();
	LCD_EN=0;
	LCD_Delay();
}
/**
  * @brief  LCD1602设置光标位置
  * @param  Line 行位置，范围：1~2
  * @param  Column 列位置，范围：1~16
  * @retval 无
  */
void LCD_SetCursor(unsigned char Line,unsigned char Column)
{
	if(Line==1)
	{
		LCD_WriteCommand(0x80|(Column-1));
	}
	else if(Line==2)
	{
		LCD_WriteCommand(0x80|(Column-1+0x40));
	}
}
/**
  * @brief  LCD1602初始化函数
  * @param  无
  * @retval 无
  */
void LCD_Init()
{
	LCD_WriteCommand(0x38);//八位数据接口，两行显示，5*7点阵
	LCD_WriteCommand(0x0c);//显示开，光标关，闪烁关
	LCD_WriteCommand(0x06);//数据读写操作后，光标自动加一，画面不动
	LCD_WriteCommand(0x01);//光标复位，清屏
}
/**
  * @brief  在LCD1602指定位置上显示一个字符
  * @param  Line 行位置，范围：1~2
  * @param  Column 列位置，范围：1~16
  * @param  Char 要显示的字符
  * @retval 无
  */
void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char)
{
	LCD_SetCursor(Line,Column);
	LCD_WriteData(Char);
}
/**
  * @brief  在LCD1602指定位置开始显示所给字符串
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  String 要显示的字符串
  * @retval 无
  */
void LCD_ShowString(unsigned char Line,unsigned char Column,char *String)
{
	unsigned char i;
	LCD_SetCursor(Line,Column);
	for(i=0;String[i]!='\0';i++)
	{
		LCD_WriteData(String[i]);
	}
}
/**
  * @brief  返回值=X的Y次方
  */
int LCD_Pow(int X,int Y)
{
	unsigned char i;
	int Result=1;
	for(i=0;i<Y;i++)
	{
		Result*=X;
	}
	return Result;
}
/**
  * @brief  在LCD1602指定位置开始显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~65535
  * @param  Length 要显示数字的长度，范围：1~5
  * @retval 无
  */
void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
	unsigned char i;
	LCD_SetCursor(Line,Column);
	for(i=Length;i>0;i--)
	{
		LCD_WriteData(Number/LCD_Pow(10,i-1)%10+'0');
	}
}
/**
  * @brief  在LCD1602指定位置开始以有符号十进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：-32768~32767
  * @param  Length 要显示数字的长度，范围：1~5
  * @retval 无
  */
void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length)
{
	unsigned char i;
	unsigned int Number1;
	LCD_SetCursor(Line,Column);
	if(Number>=0)
	{
		LCD_WriteData('+');
		Number1=Number;
	}
	else
	{
		LCD_WriteData('-');
		Number1=-Number;
	}
	for(i=Length;i>0;i--)
	{
		LCD_WriteData(Number1/LCD_Pow(10,i-1)%10+'0');
	}
}
/**
  * @brief  在LCD1602指定位置开始以十六进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~0xFFFF
  * @param  Length 要显示数字的长度，范围：1~4
  * @retval 无
  */
void LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
	unsigned char i,SingleNumber;
	LCD_SetCursor(Line,Column);
	for(i=Length;i>0;i--)
	{
		SingleNumber=Number/LCD_Pow(16,i-1)%16;
		if(SingleNumber<10)
		{
			LCD_WriteData(SingleNumber+'0');
		}
		else
		{
			LCD_WriteData(SingleNumber-10+'A');
		}
	}
}
/**
  * @brief  在LCD1602指定位置开始以二进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111
  * @param  Length 要显示数字的长度，范围：1~16
  * @retval 无
  */
void LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
	unsigned char i;
	LCD_SetCursor(Line,Column);
	for(i=Length;i>0;i--)
	{
		LCD_WriteData(Number/LCD_Pow(2,i-1)%2+'0');
	}
}
```

### Timer0.h

```c
#ifndef __TIMER0_H__
#define __TIMER0_H__

void Timer0_Init(void);

#endif
```

```c
#include <REGX52.H>
void Timer0_Init(void)
{
	TMOD &= 0xF0;
	TMOD |= 0x01;
	TL0 = 0x66;				//设置定时初始值
	TH0 = 0xFC;				//设置定时初始值
	ET0 = 1;
	EA = 1;
	TR0 = 1;
}

/*定时器0延时1s模板
void Timer0_Routine(void)	interrupt 1
{
	static unsigned int T0Count;
	TL0 = 0x66;				//设置定时初始值
	TH0 = 0xFC;				//设置定时初始值
	T0Count++;
	if(T0Count>=1000)
	{
		
		T0Count=0;
	}
}
*/
```

### UART.h

```c
#ifndef __UART_H__
#define __UART_H__

void UartInit(void);
void UART_SendData(unsigned char Data);
unsigned char UART_ReceiveData(void);

#endif
```

```c
#include <REGX52.H>

void UartInit(void)		//4800bps@11.0592MHz
{
	PCON &= 0x7F;		//波特率不倍速
	SCON = 0x50;		//8位数据,可变波特率
	TMOD &= 0x0F;		//设置定时器模式
	TMOD |= 0x20;		//设置定时器模式
	TL1 = 0xFA;			//设置定时初始值
	TH1 = 0xFA;			//设置定时重载值
	ET1 = 0;			//禁止定时器中断
	TR1 = 1;			//定时器1开始计时
	ES = 1;
	EA = 1;
}
void UART_SendData(unsigned char Data)
{
	SBUF = Data;
	TI = 0;
}
unsigned char UART_ReceiveData(void)
{
	unsigned char Data;
	Data = SBUF;
	return Data;
}
```

### 74HC595.h

```c
#ifndef __74HC595_H__
#define __74HC595_H__

void _74HC595_Init(void);
void _74HC595_WriteData(unsigned char Data);

#endif
```

```c
#include <REGX52.H>
#include "Delay.h"
sbit __74HC595_RCLK = P3^5;
sbit __74HC595_SRCLK = P3^6;
sbit __74HC595_SER = P3^4;
/**
  * @brief  74HC595初始化
  * @param  无
  * @retval 无
  */
void _74HC595_Init(void)
{
	__74HC595_RCLK = 0;
	__74HC595_SRCLK = 0;
}
/**
  * @brief  向74HC595中写入数据
  * @param  Data 写入一个字节的数据
  * @retval 无
  */
void _74HC595_WriteData(unsigned char Data)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		__74HC595_SER = Data&(0x01<<i);
		__74HC595_SRCLK = 1;
		__74HC595_SRCLK = 0;
	}
	__74HC595_RCLK = 1;
	__74HC595_RCLK = 0;
}
```

MatrixLED.h

```c
#ifndef __MATRIXLED_H__
#define __MATRIXLED_H__

void MatrixLED_Show(unsigned char Column, Data);

#endif
```

```c
#include <REGX52.H>
#include "74HC595.h"
#include "Delay.h"
/**
  * @brief  LED点阵屏显示静态图像
  * @param  Column 点亮第*列
  * @param  Column 第*列点亮的LED
  * @retval 无
  */
void MatrixLED_Show(unsigned char Column, Data)
{
	_74HC595_WriteData(Data);
	P0 = ~(0x80>>Column);
	Delay(1);
	P0 = 0xFF;
}
```

### DS1302.h

```c
#ifndef __DS1302_H__
#define __DS1302_H__

//外部可调用时间数组，索引0~6分别为年、月、日、时、分、秒、星期
extern unsigned char DS1302_Time[];

void DS1302_Init(void);
void DS1302_WriteByte(unsigned char Command,Data);
unsigned char DS1302_ReadByte(unsigned char Command);
void DS1302_SetTime(void);
void DS1302_ReadTime(void);

#endif
```

```c
#include <REGX52.H>

//引脚定义
sbit DS1302_SCLK=P3^6;
sbit DS1302_IO=P3^4;
sbit DS1302_CE=P3^5;

//寄存器写入地址/指令定义
#define DS1302_SECOND		0x80
#define DS1302_MINUTE		0x82
#define DS1302_HOUR			0x84
#define DS1302_DATE			0x86
#define DS1302_MONTH		0x88
#define DS1302_DAY			0x8A
#define DS1302_YEAR			0x8C
#define DS1302_WP			0x8E

//时间数组，索引0~6分别为年、月、日、时、分、秒、星期
unsigned char DS1302_Time[]={19,11,16,12,59,55,6};

/**
  * @brief  DS1302初始化
  * @param  无
  * @retval 无
  */
void DS1302_Init(void)
{
	DS1302_CE=0;
	DS1302_SCLK=0;
}

/**
  * @brief  DS1302写一个字节
  * @param  Command 命令字/地址
  * @param  Data 要写入的数据
  * @retval 无
  */
void DS1302_WriteByte(unsigned char Command,Data)
{
	unsigned char i;
	DS1302_CE=1;
	for(i=0;i<8;i++)
	{
		DS1302_IO=Command&(0x01<<i);
		DS1302_SCLK=1;
		DS1302_SCLK=0;
	}
	for(i=0;i<8;i++)
	{
		DS1302_IO=Data&(0x01<<i);
		DS1302_SCLK=1;
		DS1302_SCLK=0;
	}
	DS1302_CE=0;
}

/**
  * @brief  DS1302读一个字节
  * @param  Command 命令字/地址
  * @retval 读出的数据
  */
unsigned char DS1302_ReadByte(unsigned char Command)
{
	unsigned char i,Data=0x00;
	Command|=0x01;	//将指令转换为读指令
	DS1302_CE=1;
	for(i=0;i<8;i++)
	{
		DS1302_IO=Command&(0x01<<i);
		DS1302_SCLK=0;
		DS1302_SCLK=1;
	}
	for(i=0;i<8;i++)
	{
		DS1302_SCLK=1;
		DS1302_SCLK=0;
		if(DS1302_IO){Data|=(0x01<<i);}
	}
	DS1302_CE=0;
	DS1302_IO=0;	//读取后将IO设置为0，否则读出的数据会出错
	return Data;
}

/**
  * @brief  DS1302设置时间，调用之后，DS1302_Time数组的数字会被设置到DS1302中
  * @param  无
  * @retval 无
  */
void DS1302_SetTime(void)
{
	DS1302_WriteByte(DS1302_WP,0x00);
	DS1302_WriteByte(DS1302_YEAR,DS1302_Time[0]/10*16+DS1302_Time[0]%10);//十进制转BCD码后写入
	DS1302_WriteByte(DS1302_MONTH,DS1302_Time[1]/10*16+DS1302_Time[1]%10);
	DS1302_WriteByte(DS1302_DATE,DS1302_Time[2]/10*16+DS1302_Time[2]%10);
	DS1302_WriteByte(DS1302_HOUR,DS1302_Time[3]/10*16+DS1302_Time[3]%10);
	DS1302_WriteByte(DS1302_MINUTE,DS1302_Time[4]/10*16+DS1302_Time[4]%10);
	DS1302_WriteByte(DS1302_SECOND,DS1302_Time[5]/10*16+DS1302_Time[5]%10);
	DS1302_WriteByte(DS1302_DAY,DS1302_Time[6]/10*16+DS1302_Time[6]%10);
	DS1302_WriteByte(DS1302_WP,0x80);
}

/**
  * @brief  DS1302读取时间，调用之后，DS1302中的数据会被读取到DS1302_Time数组中
  * @param  无
  * @retval 无
  */
void DS1302_ReadTime(void)
{
	unsigned char Temp;
	Temp=DS1302_ReadByte(DS1302_YEAR);
	DS1302_Time[0]=Temp/16*10+Temp%16;//BCD码转十进制后读取
	Temp=DS1302_ReadByte(DS1302_MONTH);
	DS1302_Time[1]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_DATE);
	DS1302_Time[2]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_HOUR);
	DS1302_Time[3]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_MINUTE);
	DS1302_Time[4]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_SECOND);
	DS1302_Time[5]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadByte(DS1302_DAY);
	DS1302_Time[6]=Temp/16*10+Temp%16;
}
```

### Buzzer.h

```c
#ifndef __BUZZER_H__
#define __BUZZER_H__

void Buzzer_Time(unsigned int ms);

#endif
```

```c
#include <REGX52.H>
#include <INTRINS.H>

//蜂鸣器端口：
sbit Buzzer=P1^5;

/**
  * @brief  蜂鸣器私有延时函数，延时500us
  * @param  无
  * @retval 无
  */
void Buzzer_Delay500us()		//@12.000MHz
{
	unsigned char i;

	_nop_();
	i = 247;
	while (--i);
}

/**
  * @brief  蜂鸣器发声
  * @param  ms 发声的时长，范围：0~32767
  * @retval 无
  */
void Buzzer_Time(unsigned int ms)
{
	unsigned int i;
	for(i=0;i<ms*2;i++)
	{
		Buzzer=!Buzzer;
		Buzzer_Delay500us();
	}
}
```

### I2C.h

```c
#ifndef __I2C_H__
#define __I2C_H__

void I2C_Start(void);
void I2C_Stop(void);
void I2C_SendByte(unsigned char Byte);
unsigned char I2C_ReceiveByte(void);
void I2C_SendAck(unsigned char AckBit);
unsigned char I2C_ReceiveAck(void);

#endif
```

```c
#include <REGX52.H>

sbit I2C_SCL=P2^1;
sbit I2C_SDA=P2^0;

/**
  * @brief  I2C开始
  * @param  无
  * @retval 无
  */
void I2C_Start(void)
{
	I2C_SDA=1;
	I2C_SCL=1;
	I2C_SDA=0;
	I2C_SCL=0;
}

/**
  * @brief  I2C停止
  * @param  无
  * @retval 无
  */
void I2C_Stop(void)
{
	I2C_SDA=0;
	I2C_SCL=1;
	I2C_SDA=1;
}

/**
  * @brief  I2C发送一个字节
  * @param  Byte 要发送的字节
  * @retval 无
  */
void I2C_SendByte(unsigned char Byte)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		I2C_SDA=Byte&(0x80>>i);
		I2C_SCL=1;
		I2C_SCL=0;
	}
}

/**
  * @brief  I2C接收一个字节
  * @param  无
  * @retval 接收到的一个字节数据
  */
unsigned char I2C_ReceiveByte(void)
{
	unsigned char i,Byte=0x00;
	I2C_SDA=1;
	for(i=0;i<8;i++)
	{
		I2C_SCL=1;
		if(I2C_SDA){Byte|=(0x80>>i);}
		I2C_SCL=0;
	}
	return Byte;
}

/**
  * @brief  I2C发送应答
  * @param  AckBit 应答位，0为应答，1为非应答
  * @retval 无
  */
void I2C_SendAck(unsigned char AckBit)
{
	I2C_SDA=AckBit;
	I2C_SCL=1;
	I2C_SCL=0;
}

/**
  * @brief  I2C接收应答位
  * @param  无
  * @retval 接收到的应答位，0为应答，1为非应答
  */
unsigned char I2C_ReceiveAck(void)
{
	unsigned char AckBit;
	I2C_SDA=1;
	I2C_SCL=1;
	AckBit=I2C_SDA;
	I2C_SCL=0;
	return AckBit;
}
```

### AT24C02.h

```c
#ifndef __AT24C02_H__
#define __AT24C02_H__

void AT24C02_WriteByte(unsigned char WordAddress,Data);
unsigned char AT24C02_ReadByte(unsigned char WordAddress);

#endif
```

```c
#include <REGX52.H>
#include "I2C.h"

#define AT24C02_ADDRESS		0xA0

/**
  * @brief  AT24C02写入一个字节
  * @param  WordAddress 要写入字节的地址
  * @param  Data 要写入的数据
  * @retval 无
  */
void AT24C02_WriteByte(unsigned char WordAddress,Data)
{
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS);
	I2C_ReceiveAck();
	I2C_SendByte(WordAddress);
	I2C_ReceiveAck();
	I2C_SendByte(Data);
	I2C_ReceiveAck();
	I2C_Stop();
}

/**
  * @brief  AT24C02读取一个字节
  * @param  WordAddress 要读出字节的地址
  * @retval 读出的数据
  */
unsigned char AT24C02_ReadByte(unsigned char WordAddress)
{
	unsigned char Data;
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS);
	I2C_ReceiveAck();
	I2C_SendByte(WordAddress);
	I2C_ReceiveAck();
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS|0x01);
	I2C_ReceiveAck();
	Data=I2C_ReceiveByte();
	I2C_SendAck(1);
	I2C_Stop();
	return Data;
}
```

### OneWire.h

```c
#ifndef __ONEWIRE_H__
#define __ONEWIRE_H__

unsigned char OneWire_Init(void);
void OneWire_SendBit(unsigned char Bit);
unsigned char OneWire_ReceiveBit(void);
void OneWire_SendByte(unsigned char Byte);
unsigned char OneWire_ReceiveByte(void);

#endif
```

```c
#include <REGX52.H>

//引脚定义
sbit OneWire_DQ=P3^7;

/**
  * @brief  单总线初始化
  * @param  无
  * @retval 从机响应位，0为响应，1为未响应
  */
unsigned char OneWire_Init(void)
{
	unsigned char i;
	unsigned char AckBit;
	OneWire_DQ=1;
	OneWire_DQ=0;
	i = 247;while (--i);		//Delay 500us
	OneWire_DQ=1;
	i = 32;while (--i);			//Delay 70us
	AckBit=OneWire_DQ;
	i = 247;while (--i);		//Delay 500us
	return AckBit;
}

/**
  * @brief  单总线发送一位
  * @param  Bit 要发送的位
  * @retval 无
  */
void OneWire_SendBit(unsigned char Bit)
{
	unsigned char i;
	OneWire_DQ=0;
	i = 4;while (--i);			//Delay 10us
	OneWire_DQ=Bit;
	i = 24;while (--i);			//Delay 50us
	OneWire_DQ=1;
}

/**
  * @brief  单总线接收一位
  * @param  无
  * @retval 读取的位
  */
unsigned char OneWire_ReceiveBit(void)
{
	unsigned char i;
	unsigned char Bit;
	OneWire_DQ=0;
	i = 2;while (--i);			//Delay 5us
	OneWire_DQ=1;
	i = 2;while (--i);			//Delay 5us
	Bit=OneWire_DQ;
	i = 24;while (--i);			//Delay 50us
	return Bit;
}

/**
  * @brief  单总线发送一个字节
  * @param  Byte 要发送的字节
  * @retval 无
  */
void OneWire_SendByte(unsigned char Byte)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		OneWire_SendBit(Byte&(0x01<<i));
	}
}

/**
  * @brief  单总线接收一个字节
  * @param  无
  * @retval 接收的一个字节
  */
unsigned char OneWire_ReceiveByte(void)
{
	unsigned char i;
	unsigned char Byte=0x00;
	for(i=0;i<8;i++)
	{
		if(OneWire_ReceiveBit()){Byte|=(0x01<<i);}
	}
	return Byte;
}
```

### DS18B20.h

```c
#ifndef __DS18B20_H__
#define __DS18B20_H__

void DS18B20_ConvertT(void);
float DS18B20_ReadT(void);

#endif
```

```c
#include <REGX52.H>
#include "OneWire.h"

//DS18B20指令
#define DS18B20_SKIP_ROM			0xCC
#define DS18B20_CONVERT_T			0x44
#define DS18B20_READ_SCRATCHPAD 	0xBE

/**
  * @brief  DS18B20开始温度变换
  * @param  无
  * @retval 无
  */
void DS18B20_ConvertT(void)
{
	OneWire_Init();
	OneWire_SendByte(DS18B20_SKIP_ROM);
	OneWire_SendByte(DS18B20_CONVERT_T);
}

/**
  * @brief  DS18B20读取温度
  * @param  无
  * @retval 温度数值
  */
float DS18B20_ReadT(void)
{
	unsigned char TLSB,TMSB;
	int Temp;
	float T;
	OneWire_Init();
	OneWire_SendByte(DS18B20_SKIP_ROM);
	OneWire_SendByte(DS18B20_READ_SCRATCHPAD);
	TLSB=OneWire_ReceiveByte();
	TMSB=OneWire_ReceiveByte();
	Temp=(TMSB<<8)|TLSB;
	T=Temp/16.0;
	return T;
}
```

### XPT2046.h

```c
#ifndef __XPT2046_H__
#define __XPT2046_H__

#define XPT2046_VBAT	0xAC
#define XPT2046_AUX		0xEC
#define XPT2046_XP		0x9C	//0xBC
#define XPT2046_YP		0xDC

unsigned int XPT2046_ReadAD(unsigned char Command);

#endif
```

```c
#include <REGX52.H>
#include <INTRINS.H>

//引脚定义
sbit XPY2046_DIN=P3^4;
sbit XPY2046_CS=P3^5;
sbit XPY2046_DCLK=P3^6;
sbit XPY2046_DOUT=P3^7;

/**
  * @brief  ZPT2046读取AD值
  * @param  Command 命令字，范围：头文件内定义的宏，结尾的数字表示转换的位数
  * @retval AD转换后的数字量，范围：8位为0~255，12位为0~4095
  */
unsigned int XPT2046_ReadAD(unsigned char Command)
{
	unsigned char i;
	unsigned int Data=0;
	XPY2046_DCLK=0;
	XPY2046_CS=0;
	for(i=0;i<8;i++)
	{
		XPY2046_DIN=Command&(0x80>>i);
		XPY2046_DCLK=1;
		XPY2046_DCLK=0;
	}
	for(i=0;i<16;i++)
	{
		XPY2046_DCLK=1;
		XPY2046_DCLK=0;
		if(XPY2046_DOUT){Data|=(0x8000>>i);}
	}
	XPY2046_CS=1;
	return Data>>8;
}
```

### Int0.h

```c
#ifndef __INT0_H__
#define __INT0_H__

void Int0_Init(void);

#endif
```

```c
#include <REGX52.H>

/**
  * @brief  外部中断0初始化
  * @param  无
  * @retval 无
  */
void Int0_Init(void)
{
	IT0=1;
	IE0=0;
	EX0=1;
	EA=1;
	PX0=1;
}

/*外部中断0中断函数模板
void Int0_Routine(void) interrupt 0
{
	
}
*/
```

### IR.h

```c
#ifndef __IR_H__
#define __IR_H__

#define IR_POWER		0x45
#define IR_MODE			0x46
#define IR_MUTE			0x47
#define IR_START_STOP	0x44
#define IR_PREVIOUS		0x40
#define IR_NEXT			0x43
#define IR_EQ			0x07
#define IR_VOL_MINUS	0x15
#define IR_VOL_ADD		0x09
#define IR_0			0x16
#define IR_RPT			0x19
#define IR_USD			0x0D
#define IR_1			0x0C
#define IR_2			0x18
#define IR_3			0x5E
#define IR_4			0x08
#define IR_5			0x1C
#define IR_6			0x5A
#define IR_7			0x42
#define IR_8			0x52
#define IR_9			0x4A

void IR_Init(void);
unsigned char IR_GetDataFlag(void);
unsigned char IR_GetRepeatFlag(void);
unsigned char IR_GetAddress(void);
unsigned char IR_GetCommand(void);

#endif
```

```c
#include <REGX52.H>
#include "Timer0.h"
#include "Int0.h"

unsigned int IR_Time;
unsigned char IR_State;

unsigned char IR_Data[4];
unsigned char IR_pData;

unsigned char IR_DataFlag;
unsigned char IR_RepeatFlag;
unsigned char IR_Address;
unsigned char IR_Command;

/**
  * @brief  红外遥控初始化
  * @param  无
  * @retval 无
  */
void IR_Init(void)
{
	Timer0_Init();
	Int0_Init();
}

/**
  * @brief  红外遥控获取收到数据帧标志位
  * @param  无
  * @retval 是否收到数据帧，1为收到，0为未收到
  */
unsigned char IR_GetDataFlag(void)
{
	if(IR_DataFlag)
	{
		IR_DataFlag=0;
		return 1;
	}
	return 0;
}

/**
  * @brief  红外遥控获取收到连发帧标志位
  * @param  无
  * @retval 是否收到连发帧，1为收到，0为未收到
  */
unsigned char IR_GetRepeatFlag(void)
{
	if(IR_RepeatFlag)
	{
		IR_RepeatFlag=0;
		return 1;
	}
	return 0;
}

/**
  * @brief  红外遥控获取收到的地址数据
  * @param  无
  * @retval 收到的地址数据
  */
unsigned char IR_GetAddress(void)
{
	return IR_Address;
}

/**
  * @brief  红外遥控获取收到的命令数据
  * @param  无
  * @retval 收到的命令数据
  */
unsigned char IR_GetCommand(void)
{
	return IR_Command;
}

//外部中断0中断函数，下降沿触发执行
void Int0_Routine(void) interrupt 0
{
	if(IR_State==0)				//状态0，空闲状态
	{
		Timer0_SetCounter(0);	//定时计数器清0
		Timer0_Run(1);			//定时器启动
		IR_State=1;				//置状态为1
	}
	else if(IR_State==1)		//状态1，等待Start信号或Repeat信号
	{
		IR_Time=Timer0_GetCounter();	//获取上一次中断到此次中断的时间
		Timer0_SetCounter(0);	//定时计数器清0
		//如果计时为13.5ms，则接收到了Start信号（判定值在12MHz晶振下为13500，在11.0592MHz晶振下为12442）
		if(IR_Time>12442-500 && IR_Time<12442+500)
		{
			IR_State=2;			//置状态为2
		}
		//如果计时为11.25ms，则接收到了Repeat信号（判定值在12MHz晶振下为11250，在11.0592MHz晶振下为10368）
		else if(IR_Time>10368-500 && IR_Time<10368+500)
		{
			IR_RepeatFlag=1;	//置收到连发帧标志位为1
			Timer0_Run(0);		//定时器停止
			IR_State=0;			//置状态为0
		}
		else					//接收出错
		{
			IR_State=1;			//置状态为1
		}
	}
	else if(IR_State==2)		//状态2，接收数据
	{
		IR_Time=Timer0_GetCounter();	//获取上一次中断到此次中断的时间
		Timer0_SetCounter(0);	//定时计数器清0
		//如果计时为1120us，则接收到了数据0（判定值在12MHz晶振下为1120，在11.0592MHz晶振下为1032）
		if(IR_Time>1032-500 && IR_Time<1032+500)
		{
			IR_Data[IR_pData/8]&=~(0x01<<(IR_pData%8));	//数据对应位清0
			IR_pData++;			//数据位置指针自增
		}
		//如果计时为2250us，则接收到了数据1（判定值在12MHz晶振下为2250，在11.0592MHz晶振下为2074）
		else if(IR_Time>2074-500 && IR_Time<2074+500)
		{
			IR_Data[IR_pData/8]|=(0x01<<(IR_pData%8));	//数据对应位置1
			IR_pData++;			//数据位置指针自增
		}
		else					//接收出错
		{
			IR_pData=0;			//数据位置指针清0
			IR_State=1;			//置状态为1
		}
		if(IR_pData>=32)		//如果接收到了32位数据
		{
			IR_pData=0;			//数据位置指针清0
			if((IR_Data[0]==~IR_Data[1]) && (IR_Data[2]==~IR_Data[3]))	//数据验证
			{
				IR_Address=IR_Data[0];	//转存数据
				IR_Command=IR_Data[2];
				IR_DataFlag=1;	//置收到连发帧标志位为1
			}
			Timer0_Run(0);		//定时器停止
			IR_State=0;			//置状态为0
		}
	}
}
```

